% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/discretize.R
\name{discretize}
\alias{discretize}
\alias{discretize.ts}
\alias{discretize.default}
\title{Convert Time-Series Data into Wide Format Sequence Data}
\usage{
discretize(
  data,
  n_states,
  labels = 1:n_states,
  method = "kmeans",
  unused_fn = dplyr::first,
  ...
)

\method{discretize}{ts}(
  data,
  n_states,
  labels = 1:n_states,
  method = "kmeans",
  unused_fn = dplyr::first,
  ...
)

\method{discretize}{default}(
  data,
  id_col,
  value_col,
  order_col,
  n_states,
  labels = 1:n_states,
  method = "kmeans",
  unused_fn = dplyr::first,
  ...
)
}
\arguments{
\item{data}{[\code{data.frame}, \code{ts}, \code{tsn}, \code{numeric()}]\cr Either time-series
data in long format (\code{data.frame}, \code{tsn}), a time-series object (\code{ts}), or
a vector of values.}

\item{n_states}{[\code{integer(1)}]\cr The number of states to discretize the
data into.}

\item{labels}{[\code{character()}]\cr A vector of names for the states. The
length must be \code{n_states} The defaults is consecutive numbering,
i.e. \code{1:n_states}.}

\item{method}{[\code{character(1)}]\cr The name of the discretization method to
use.
\itemize{
\item \code{kmeans}: for K-means clustering (the default).
\item \code{width}: for equal width binning.
\item \code{quantile}: for quantile-based binning.
\item \code{kde}: for binning based on kernel density estimation.
\item \code{gaussian}: for a Gaussian mixture model.
}}

\item{unused_fn}{[\code{function}]\cr How to handle extra columns when pivoting
to wide format. See \code{\link[tidyr:pivot_wider]{tidyr::pivot_wider()}}. The default is to keep all
columns and to use the first value.}

\item{...}{Additional arguments passed to the discretization method
(\code{\link[stats:kmeans]{stats::kmeans()}} for \code{kmeans}, \code{\link[stats:density]{stats::density()}} and
\code{\link[pracma:findpeaks]{pracma::findpeaks()}} for \code{kde}, and
\code{\link[mclust:Mclust]{mclust::Mclust()}} for \code{gaussian}).}

\item{id_col}{[\code{character(1)}]\cr The name of the column that contains
the unique identifiers.}

\item{value_col}{[\code{character(1)}]\cr The name of the column that contains
the data values.}

\item{order_col}{[\code{character(1)}]\cr The name of the column that contains
the time values (not required if the data is already in order),}
}
\value{
TODO
}
\description{
Converts time-series data into sequence data via discretization.
Various methods for discretization are available including gaussian
mixtures, K-means clustering and kernel density based binning.
}
\examples{
# Long format data
ts_data <- data.frame(
  id = gl(10, 100),
  series = c(
    replicate(
      10,
      stats::arima.sim(list(order = c(2, 1, 0), ar = c(0.5, 0.2)), n = 99)
    )
  )
)
data <- discretize(ts_data, "id", "series", n_states = 3)

# Time-series data
data <- discretize(EuStockMarkets, n_states = 3)

}
